
\appendix


# \Surkal: Base spec defined operations

TODO: ask which needs bool check

TODO PI gadget

TODO plonkup gadgets:

- higher order: multi lookup, tbl
- concrete: multi unary lookup, range check tbl


| $g: \Ggt$                | $\text{eval}(g, \vec{x})$     | remarks                 |
|:-------------------------:|:-----------------------------:|:------------------------|
| Input$_i()$               | $(x_i)$                       | from trace              |
| Const$_{s,p}()$           | $(s)$                         |                         |
| Add$(x,y)$                | $(x+y)$                       |                         |
| Mul$(x,y)$                | $(x \times y)$                |                         |
| Inv$(x)$                  | $(x^{-1})$                    |                         |
| Pow7$(x)$                 | $(x^7)$                       |                         |
| If$(b,x,y)$               | $(b ? x : y)$                 |                         |
| Lookup$_T(x,y)$           | $\maybe{(z)}{(x,y,z) \in T}$  |                         |
| PtAdd$(x_P,y_P,x_Q,y_Q)$  | $(x_R, y_R)$                  | Arkworks point add      |
| Poseidon$(a,b,c)$         | $(a',b',c')$                  | Mina poseidon 5 rounds  |
| Public$(x)$               | $()$                          |                         |
| Bit$(b)$                  | $()$                          |                         |
| IsAdd$(x,y,z)$            | $()$                          |                         |
| IsMul$(x,y,z)$            | $()$                          |                         |
| IsLookup$_T(x,y,z)$       | $()$                          |                         |

# Notation

\begin{longtable*}{@{} c l @{}}
\toprule
\textbf{Types and Terms} & \textbf{Description} \\
\hline
$\Uni$ & The type of all types \\
\hline
$\Nb$ & The type of natural numbers \\
\hline
$\Fb_q$ & The finite field of order $q$ \\
\hline
$T^n$ & The type of vectors of type $T$ of length $n$ \\
$()$ & The vector term of length $0$ \\
$\vec{x}$ & A vector term \\
$(x_1, x_2, \cdots, x_n)$ & A vector term literal \\
\hline
$T \times U$ & The type of product / tuple of $T$ and $U$ \\
$(t, u)$ & A product / tuple literal \\
\hline
$\Unit$ & The unit type \\
$()$ & The unit term \\
\hline
$X \to Y$ & The type of functions from $X$ to $Y$ \\
$\lambda x. f(x)$ & A function term / lambda abstraction \\
\hline
$X \pto Y$ & The type of partial functions from $X$ to $Y$ \\
$\bot$ & The empty partial function \\
$f[x \mapsto y]$ & A partial function that maps $x$ to $y$ \\
\hline
$T + U$ & The type of disjoint union / sum type of type $T$ and $U$ \\
$\inl(t)$ & A left injection of $t$ into the disjoint union \\
$\inr(u)$ & A right injection of $u$ into the disjoint union \\
 & The injection constructor can be omitted if the context is clear \\
\hline
\end{longtable*}


\begin{longtable*}{@{} c l l @{}}
\toprule
\textbf{Function} & \textbf{Definition} & \textbf{Description} \\
\hline
$[n]$ & $\set{1,2,\ldots,n-1}$ & Set of naturals from $1$ to $n-1$ \\
$[n..m]$ & $\set{n,n+1,\ldots,m-1}$ & Set of naturals with lower bound $n$ to $m-1$ \\
$(s..t)$ & $\begin{cases} () & t \leq s \\ s \cat (s+1 .. t) \end{cases}$ & Vector of naturals from $s$ to $t-1$ \\
\hline
$y \cat \vec{x}$ & $(y, x_1, x_2, \cdots, x_n)$ & Prepend $y$ to vector $\vec{x}$ \\
$\vec{x} \cat y$ & $(x_1, x_2, \cdots, x_n, y)$ & Append $y$ to vector $\vec{x}$ \\
$\vec{x} \cat \vec{y}$ & $\begin{cases} \vec{y} & \vec{x} = () \\ \vec{x}' \cat (x \cat \vec{y}) & \vec{x} = \vec{x'} \cat x \end{cases}$ & Concatenate vectors $\vec{x}$ and $\vec{y}$ \\
\hline
$\vec{x} \odot \vec{y}$ & $((x_1,y_1),\cdots,(x_n,y_n))$ & Zip vectors $\vec{x}$ and $\vec{y}$ (Hadamard product) \\
\hline
$\psi(x_{\phi(i)})$ & $\forall i \in [|\vec{x}|+1]. \phi(i) \Rightarrow \psi(x_i)$ & Assert vector e.g. $a_{i>1} = a_{i-1} \cdot x$ \\
\hline
$\vec{x}[i..j]$ & & subvector from $i$ to $j-1$ \\
\hline
$X_{i,j}$ & $X: T^{n\times k}\ X_{i,j} = X_{i + (j-1) \times n}$ & Vector as matrix access \\
\hline
$f[\vec{x}]$ & $(f(x_1), f(x_2), \ldots, f(x_n))$ & Map function $f$ over vector $\vec{x}$ \\
$\text{repl}(n,x)$ & $(\lambda\_. x)[n+1]$ & create a vector with $n$ elements of $x$ \\
\hline
$\vec{x} \setminus X$ &  & Remove all elements in set $X$ from vector $\vec{x}$ \\
\hline
$\maybe{x}{\phi(x)}$ & $\begin{cases} x & \phi(x) \\ \bot & \otherwise \end{cases}$ & Maybe: $x$ if $\phi(x)$, else $\bot$ \\
$x ? y$ & $\begin{cases} x & x \neq \bot \\ y & \otherwise \end{cases}$ & Nullish Coalescing: $x$ unless it is $\bot$ then $y$ \\
\hline
$f[\vec{x} \mapsto \vec{y}]$ & $\begin{cases} & \vec{x} = x \cat \vec{x}' \\ f[x \mapsto y][\vec{x}' \mapsto \vec{y}'] & \vec{y} = y \cat \vec{y}' \\ f & \otherwise \end{cases}$ & Vector append to partial function $f$ \\
\hline
$\langle \omega \rangle$ & $\set{\omega^i \mid i \in \Nb}$ & The cyclic group generated by $\omega$ \\
\hline
$k\langle \omega \rangle$ & $\set{k\omega^i \middle\vert i \in \Nb}$ & Coset of a cyclic group \\
\hline
\end{longtable*}

\begin{longtable*}{@{} l l l @{}}
\toprule
\textbf{Identity} & \textbf{Example} & \textbf{Description} \\
\hline
$T \times U \times V = (T \times U) \times V = T \times (U \times V)$ & $(a, b, c) = ((a, b), c) = (a, (b, c))$ & Associative product types \\
\hline
$\Unit \times T = T \times \Unit = T$ & $((), t) = (t, ()) = t$ & Product has unit \\
\hline
$X \to Y \to Z = (X \to Y) \to Z = X \to (Y \to Z)$ & $f(x,y)=f(\lambda x.y)=f(x)(y)$ & Associative function type \\
\hline
$X \to Y \to Z = (X \times Y) \to Z$ & $f(x,y)=f((x, y))$ & Currying \\
\hline
$\Unit \to X = X$ & $f(()) = x \leftrightarrow f = x$ & Function has unit \\
\hline
$X \pto Y = X \to \Option(Y)$ & $\bot[x \mapsto y] = \lambda x. \maybe{y}{x \mathrm{\ is\ defined}}$ & Partial are functions to options \\
\hline
$(S: \pset{T}) \to T^{|S|}$ & $\vec{x} = \set{x \middle\vert \phi(x)}$ & A set can be coerced into a vector
\end{longtable*}

**projections** - sometimes we notate $f(x)$ as $f_x$ where $f$ is a projection of object $x$; akin to field access $\mathtt{x}.\mathtt{f}$

**unused argument(s)** - we use underscores to denote that the argument is not used e.g. $\lambda \_. \cdots$, by associative product and currying, one underscore can mean multiple unused arguments.

**quantifier seperator** - $\forall x. P(x)$ instead of $\forall x: P(x)$ to disambiguate typing judgements from quantifier separators

**flattened case notation** - conditions are propagated to conditions below if they don't contradict, if a case has no term, the next termed case must satisfy it, but subsequent cases need not
$$
\begin{array}{rl}
\begin{cases}
a & \phi_1 \\
 & \phi_2 \\
b & \phi_3 \\
c & \phi_4 \\
\vdots
\end{cases} &=
\begin{cases}
a & \phi_1 \\
b & \phi_2 \land \phi_3 \\
c & \phi_2 \lor \phi_4 \\
\vdots
\end{cases}
\end{array}
$$

**abstract arithmetizer objects** - $\abst{x}$ is an abstract of a thing, e.g. $\abst{f}$ is an abstract circuit, $\abst{y}$ is an abstract value / wire


